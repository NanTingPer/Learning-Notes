# 使用钩子辅助设计

> 钩子不仅能作用于其他模组，也能作用于自己

有看我钩子教程视频的朋友会发现，我是自己钩自己，但是在实际编程中我不清楚有没有人这样用，因此，这边使用一个案例，来设计一个自钩的类型。



## 原始

---

​	就拿传统的召唤武器为例，我们通常需要编写一个武器，一个`Buff`，一个弹幕。同时还要去管理他们之间的依赖。同时他们之间还没明确的依赖关系，光类型找来找去都是一件麻烦事。

​	还有一堆需要记忆的属性，就比如`ProjectileID.Sets.MinionSacrificable[modProjectile.Type]`，每次写也都很麻烦。

​	或许你可能会说，我可以对类型进行抽象，然后在默认的执行逻辑中 例如`SetDefault`设置他。当然可以，但是当你重写时，你是不是还要`base.SetDefault`，或者你干脆把重写的这个方法设置成`sealed` 然后开一个新的方法让子类重写，那你的名字要怎么取呢。而且这样也没解决依赖不明确的问题。

```cs
public abstract class SummonItem : ModItem
{
    public override void SetDefaults()
    {
        Item.useTime = 10;
    }
}

public class MySummonItem : SummonItem
{
    public override void SetDefaults()
    {
        base.SetDefaults();
        Item.damage = 10;
    }
}
```

```cs
public abstract class SummonItem : ModItem
{
    public sealed override void SetDefaults()
    {
        Item.useTime = 10;
        SetDefaults(1);
    }

    public virtual void SetDefaults(int a) //我是天才吗，加个没用的int
    {

    }
}

public class MySummonItem : SummonItem
{
    public override void SetDefaults(int a)
    {
    }
}
```

​	如果使用传统的泛型类型，虽然是依赖绑定了，但你怎么得到对象实例，通过构造函数的话又不能被自动加载。



## 使用钩子

---

```cs
public abstract class SummonItem<TProjectile, TBuff, TSelf> : ModItem
    where TBuff : ModBuff
    where TProjectile : ModProjectile
    where TSelf : SummonItem<TProjectile, TBuff, TSelf>
{
    static SummonItem()
    {
        var tProjectileType = typeof(TProjectile);
        var tBuffType = typeof(TBuff);
        var thisType = typeof(TSelf);
        var BFIP = BindingFlags.Instance | BindingFlags.Public;

        #region Get This Method
        var itemSetDefaults = thisType
            .GetMethod(nameof(SetDefaults), BFIP);

        MonoModHooks.Add(itemSetDefaults, ItemSetDefaults);

        var itemUseItem = thisType
            .GetMethod(nameof(UseItem), BFIP);
        MonoModHooks.Add(itemUseItem, ItemUseItem);
        #endregion

        #region Get Projectile Method
        var projectilePreAI = tProjectileType
            .GetMethod(nameof(ModProjectile.PreAI), BFIP);
        MonoModHooks.Add(projectilePreAI, ModProjectilePreAI);

        var projectileSetDefault = tProjectileType
            .GetMethod(nameof(ModProjectile.SetDefaults), BFIP);
        MonoModHooks.Add(projectileSetDefault, ModProjectilSetDefault);
        #endregion

        #region Get Buff Method
        var buffSetDefault = tBuffType
            .GetMethod(nameof(ModBuff.SetStaticDefaults), BFIP);
        MonoModHooks.Add(buffSetDefault, ModBuffSetStaticDefaults);
        #endregion
    }
    public static float MinionSlots { get; set; } = 1f;

    #region This
    //在使用物品时 添加Buff
    private static bool? ItemUseItem(Func<ModItem, Player, bool?> orig, ModItem modItem, Player player)
    {
        if (!player.HasBuff<TBuff>()) {
            player.AddBuff(ModContent.BuffType<TBuff>(), 99);
        }
        return orig.Invoke(modItem, player);
    }

    //设置基础值，并设置发射弹幕等繁琐操作
    private static void ItemSetDefaults(Action<ModItem> orig, ModItem modItem)
    {
        var Item = modItem.Item;
        Item.useTime = 10;
        Item.useAnimation = 10;
        Item.autoReuse = false;
        Item.DamageType = DamageClass.Summon;
        Item.useStyle = ItemUseStyleID.Swing;

        Item.shoot = ModContent.ProjectileType<TProjectile>();
        ItemID.Sets.StaffMinionSlotsRequired[modItem.Type] = MinionSlots;
        orig.Invoke(modItem);
    }
    #endregion

    #region Projectile
    //设置为mini并且无限穿透等繁琐操作
    private static void ModProjectilSetDefault(Action<ModProjectile> orig, ModProjectile modProjectile)
    {
        var projectile = modProjectile.Projectile;
        projectile.minionSlots = MinionSlots;
        projectile.minion = true;
        projectile.friendly = true;
        projectile.ContinuouslyUpdateDamageStats = true; //基于弹幕伤害进行伤害计算
        projectile.penetrate = -1;
        projectile.tileCollide = false;

        ProjectileID.Sets.MinionSacrificable[modProjectile.Type] = true; //牺牲
        Main.projPet[modProjectile.Type] = true;
        orig.Invoke(modProjectile);
    }
	
    //因buff而牺牲
    private static bool ModProjectilePreAI(Func<ModProjectile, bool> orig, ModProjectile modProjectile)
    {
        Projectile projectile = modProjectile.Projectile;
        var player = Main.player[projectile.owner];
        if (!player.HasBuff<TBuff>()) {
            projectile.active = false;
            return false;
        } else {
            return orig?.Invoke(modProjectile) ?? false;
        }
    }
    #endregion

    #region Buff
    //设置buff基础属性
    private static void ModBuffSetStaticDefaults(Action<ModBuff> orig, ModBuff buff)
    {
        Main.debuff[buff.Type] = false;
        Main.buffNoTimeDisplay[buff.Type] = true;
        BuffID.Sets.TimeLeftDoesNotDecrease[buff.Type] = true;
        orig.Invoke(buff);
    }
    #endregion
}
```



## 创建物品

---

```cs
public class CountSummaryItem : SummonItem<CountSummaryProjectile, CountSummaryBuff, CountSummaryItem>
{
    public override void SetDefaults()
    {
        Item.damage = 20;
    }
}

public class CountSummaryProjectile : ModProjectile
{
    public override string Texture => "Terraria/Images/Projectile_" + ProjectileID.EmpressBlade;
    private Player Player => Main.player[Projectile.owner];

    public override void SetDefaults()
    {
        Projectile.height = 100;
        Projectile.width = 100;
        Projectile.damage = 20;
        Projectile.DamageType = DamageClass.Summon;
        Projectile.aiStyle = -1;
        base.SetDefaults();
    }

    public override bool MinionContactDamage()
    {
        return true;
    }
    public int count = 0;
    public override void AI()
    {
        Projectile.Center = Player.Center + new Vector2(count * 50, -100);
        base.AI();
    }
    public override void OnSpawn(IEntitySource source)
    {
        count = Player.ownedProjectileCounts[Type];
        base.OnSpawn(source);
    }
}

public class CountSummaryBuff : ModBuff
{
    public override string Texture => "Terraria/Images/Projectile_" + ProjectileID.EmpressBlade;
}
```

