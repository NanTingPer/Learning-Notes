关于收藏的联机同步

由于我未寻找到`tModLoader`给出相关方法，在物品在收藏时调用，我使用`favorited`作为关键字查找，最后找到了状态修改的地方

```cs
private static bool OverrideLeftClick(Item[] inv, int context = 0, int slot = 0)
{
	if (Main.cursorOverride == 3) {
		if (!canFavoriteAt[Math.Abs(context)])
			return false;
	
		item.favorited = !item.favorited;
		SoundEngine.PlaySound(12);
		return true;
```

这个是私有方法，被`LeftClick`调用，隶属于`Terraria.UI.ItemSlot`，在调用前后均没有看到有钩子的迹象

```cs
public static void LeftClick(Item[] inv, int context = 0, int slot = 0)
{
	Player player = Main.player[Main.myPlayer];
	bool flag = Main.mouseLeftRelease && Main.mouseLeft;
	if (flag) {
		if (OverrideLeftClick(inv, context, slot))
			return;
```

现在我们要求其更改时服务器能收到消息，所以要对他进行挂钩。

```cs
[ModuleInitializer]
internal static void ILHookItemSlot()
{
    On_ItemSlot.OverrideLeftClick += On_ItemSlot_OverrideLeftClick; ;
}

private static bool On_ItemSlot_OverrideLeftClick(On_ItemSlot.orig_OverrideLeftClick orig, Item[] inv, int context, int slot)
{
    var oldFavoritedStatu = inv[slot].favorited;
    var retValue = orig.Invoke(inv, context, slot);
    var newFavoritedStatu = inv[slot].favorited;
    if(oldFavoritedStatu != newFavoritedStatu) {
        var packet = ModLoader.GetMod(nameof(NoNPCSpawn)).GetPacket();
        packet.Write(slot);
        packet.Write(newFavoritedStatu);
        packet.Send();
    }
    return retValue;
}

public override void HandlePacket(BinaryReader reader, int whoAmI)
{
    var slot = reader.ReadInt32();
    var newFavoritedStatu = reader.ReadBoolean();
    Main.player[whoAmI].inventory[slot].favorited = newFavoritedStatu;
    base.HandlePacket(reader, whoAmI);
}
```



